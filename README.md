## Smart PDF parser (GigaChat, RAG‑friendly)

Скрипт для промышленной обработки PDF‑памяток по работе в АС:

- разбивает PDF на страницы;
- извлекает текстовый слой и делает скриншот каждой страницы;
- через GigaChat распознаёт инструкцию по скриншоту и объединяет её с текстовым слоем;
- собирает:
  - покомпонентные инструкции по страницам;
  - итоговый документ по всему PDF;
  - инкрементальный документ, где каждая новая страница уточняет уже накопленный контекст;
- помечает каждый смысловой элемент тегом источника `[SOURCE: page XXX]` для удобной привязки в RAG.

---

### Презентация продукта (короткая, «как слайды»)

#### Слайд 1 — Что это

**Smart PDF parser** — продукт для автоматической подготовки **инструкций по работе в банковских АС кредитного процесса** к загрузке в **RAG**.

Цель: превратить «человеческие» документы (часто плохо извлекаемые) в **структурированный, цитируемый, RAG‑friendly контент**: инструкции + FAQ + источники.

#### Слайд 2 — Боль бизнеса

- **Разноформатность**: инструкции приходят в PDF/сканах/слайдах, где структура “визуальная”, а не текстовая.
- **PDF как худший кейс**: текстовый слой часто неполный/битый/перемешан, таблицы и UI‑скриншоты «ломают» разметку.
- **RAG “из коробки”**: стандартные парсеры/экстракторы теряют шаги, контекст экранов и названия полей/кнопок → падает точность ответов.

#### Слайд 3 — Ключевая идея решения

Мы обрабатываем **каждую страницу** как самостоятельный «смысловой слайд» и объединяем **два источника истины**:

- **Text layer** (извлечённый текст PDF) — хорошо для машинного поиска, терминов, копируемых фрагментов.
- **Vision‑LLM распознавание скриншота страницы** — хорошо для UI‑инструкций, таблиц, схем, “визуальных” шагов.

Результат: полноценная инструкция по странице, где LLM **достраивает структуру**, но **не выдумывает факты**.

#### Слайд 4 — Пайплайн (end‑to‑end)

1) **Нормализация входа**
   - В этом репозитории пайплайн стартует с **PDF**.
   - В промышленном контуре шаг «привести всё к PDF» подключается как **внешний/опциональный этап** (например, headless‑конвертация офисных форматов).
2) **Разбиение PDF → страницы**
   - Для каждой страницы создаются: `page.txt` (текстовый слой) и `page.jpg` (рендер страницы).
3) **LLM‑распознавание (vision)**
   - По `page.jpg` модель извлекает шаги/поля/кнопки/условия, которые могли отсутствовать в тексте.
4) **Merge (инструкция по странице)**
   - LLM объединяет распознанный текст и текстовый слой в единый «чистый» фрагмент инструкции.
5) **Опционально: контекст предыдущих страниц**
   - Режим incremental: каждая новая страница уточняет общий документ, сохраняя привязку к источнику.
6) **FAQ по каждой странице**
   - LLM генерирует вопросы‑ответы “как спросит пользователь” → база FAQ на основе фактов страницы.
7) **Сборка итогов**
   - Единая инструкция + единый FAQ по документу, готовые к загрузке в RAG/поиск.

#### Слайд 5 — Что отдаём на выход (артефакты)

На один документ формируется каталог `out/<doc>/`:

- `page_XXX/page.txt` — текстовый слой страницы
- `page_XXX/page.jpg` — изображение страницы (визуальная основа)
- `page_XXX/instruction.txt` — итоговая инструкция по странице (text layer + vision)
- `page_XXX/instruction_with_context.txt` — вариант с накопленным контекстом (опционально)
- `instructions_merged.md` — склейка всех страниц (удобно для чанкинга в RAG)
- `instructions_incremental.md` — «единый смысл» + строгая трассировка источников `[SOURCE: page XXX]`
- `*_faq.xlsx` — FAQ по страницам (вопрос/ответ/источник)

#### Слайд 6 — Почему это действительно RAG‑friendly

- **Трассируемость**: каждое утверждение можно привязать к странице через `[SOURCE: page XXX]`.
- **Стабильная структура**: инструкции получаются однообразными по стилю (шаги, условия, поля), что повышает качество чанкинга.
- **Два индекса вместо одного**:
  - Инструкция — хорошо отвечает “как сделать” (процедуры).
  - FAQ — хорошо отвечает “что спросит пользователь” (вопрос‑ответ).
- **Анти‑галлюцинации в промптах**: ответ строится только из фактов входа; при недостатке данных модель должна это явно сказать (см. `rag_prompts.md`).

#### Слайд 7 — Техническая архитектура (как устроено внутри)

**Язык/стек**: Python + `PyMuPDF` (рендер/текст), `Flask` (Web UI), `gigachat`/HTTP (LLM), `openpyxl` (FAQ→Excel), `langchain` (утилиты для текстовой обработки).

**Авторизация к LLM**:

- OAuth через NGW (`Bearer access_token`)
- опционально **mTLS** (клиентские сертификаты) с приоритетом попытки запроса по сертификату и fallback на токен

**Ключевой фокус качества**:

- объединение (merge) делается по принципу: *«структурировать и нормализовать, но не расширять смысл»*;
- моковые/примерные значения в инструкциях заменяются на плейсхолдеры (`<значение>`), чтобы не “утащить” персональные данные в базу знаний.

#### Слайд 8 — Выгрузка итогов (docx/pdf)

- В проекте уже поддержана выгрузка **DOCX** через `pandoc` (для «красивого» оформления можно указать `PANDOC_REFERENCE_DOCX` со стилями).
- При необходимости выгрузка в **PDF** делается тем же подходом через `pandoc` (требуется настроенный PDF‑engine в окружении — зависит от корпоративного стенда).

#### Слайд 9 — Где это особенно полезно

- инструкции по кредитным АС с UI‑шагами (“нажмите”, “выберите”, “проверьте статус”);
- памятки, где половина смысла находится в **скриншотах экранов**, схемах и таблицах;
- документы с «битым» текстовым слоем, где обычный PDF‑парсер даёт мусор.

#### Слайд 10 — Итог

**Smart PDF parser** превращает сложные «визуальные» инструкции в:

- понятный текст (инструкция по шагам),
- FAQ для быстрых ответов,
- строгие источники (страница/слайд),

…и делает это так, чтобы контент был **максимально пригоден для RAG** и аудита.

### Структура проекта

- `img_parse.py` — низкоуровневая работа с NGW и GigaChat (получение токена, REST‑вызовы, учёт токенов).
- `process_pamphlets.py` — основной пайплайн обработки PDF:
  - Этап 1: разбор PDF на страницы (`page_XXX/page.txt`, `page_XXX/page.jpg`);
  - Этап 2: для каждой страницы распознавание скриншота и объединение с текстовым слоем;
  - Этап 3: сборка независимых инструкций по страницам в `instructions_merged.md`;
  - Этап 4: инкрементальное накопление смысла по страницам с тегами `[SOURCE: page XXX]` в `instructions_incremental.md`;
  - в конце печатает суммарное потребление токенов (`prompt`, `completion`, `total`) за запуск.
- `requirements.txt` — минимальный набор зависимостей.
- `example_env.txt` — пример содержимого `.env` (боевой `.env` в Git **не коммитим**).
- `pdfs/` — каталог для входных PDF (игнорируется Git, создаёте сами).
- `out/` — каталог для результатов (игнорируется Git, создаётся скриптом).
- `docs/pipeline.drawio` — диаграмма пайплайна (открывается в [draw.io / diagrams.net](https://app.diagrams.net/)).
- `generate_faq.py` — генерация FAQ‑вопросов по итоговой инструкции (`.md`) (3–5 вопросов на страницу).
- `generate_general_instruction.py` — генерация **общей инструкции** (`general_instruction.md`) из «простых» инструкций (page_XXX/instruction.txt или `instructions_merged.md`), без FAQ.
- `web_ui.py` — Web интерфейс: загрузка PDF → просмотр страниц (скриншот/тексты/FAQ), показ токенов, выбор model/temperature.

### Установка

```bash
git clone git@github.com:Waso-python/Smart_PDF_parser.git
cd Smart_PDF_parser

python -m venv venv
venv\Scripts\activate  # Windows
# или source venv/bin/activate для Linux/macOS

pip install -r requirements.txt
```

Создайте `.env` на основе `example_env.txt` и заполните:

- `GIGA_ACCESS_KEY` — авторизационный ключ для NGW (строка `Basic ...`);
- `GIGA_CHAT_SCOPE` — обычно `GIGACHAT_API_CORP`;
- `GIGA_NGW_URL`, `GIGA_CHAT_COMPLETIONS_URL`, `GIGA_CHAT_FILES_URL` — при необходимости переопределите под свой контур;
- `GIGA_TEXT_MODEL`, `GIGA_VISION_MODEL` — названия используемых моделей GigaChat.

### Запуск пайплайна

1. Поместите входные PDF‑файлы в каталог `pdfs/` (например, `pdfs/manual.pdf`).
2. Запустите:

```bash
python process_pamphlets.py --pdf-dir pdfs --out-dir out
```

Режим **только OCR** (без merge и без incremental), где `instruction.txt` на каждой странице формируется из OCR и включает строку источника `[SOURCE -  "Памятка - NNN"]`:

```bash
python process_pamphlets.py --pdf-dir pdfs --out-dir out --mode ocr_only
```

Аргументы:

- `--pdf-dir` — каталог с исходными PDF (по умолчанию `pdfs`);
- `--out-dir` — каталог для результатов (по умолчанию `out`).

В результате для каждого PDF `X.pdf` появится каталог `out/X/` со следующими файлами:

- `page_001/page.txt` — текстовый слой страницы 1;
- `page_001/page.jpg` — скриншот страницы 1;
- `page_001/instruction.txt` — итоговая инструкция по странице 1;
- `page_001/instruction_with_context.txt` — инструкция по страницам 1..1;
- `...`
- `instructions_merged.md` — конкатенация инструкций по всем страницам;
- `instructions_incremental.md` — единый документ с накопленным контекстом, где каждая смысловая строка имеет тег `[SOURCE: page XXX]`.

В конце работы скрипт выводит в терминал суммарное количество токенов, потраченных на все вызовы GigaChat за текущий запуск.

### Генерация FAQ

Сгенерировать 3–5 вопросов на страницу по итоговой инструкции:

```bash
python generate_faq.py --md out/<pdf>/instructions_merged.md
```

или по инкрементальному документу (если используете `[SOURCE: page XXX]`):

```bash
python generate_faq.py --md out/<pdf>/instructions_incremental.md
```

Параметр `--output-tokens` задаёт лимит `max_tokens` на один ответ модели (по умолчанию `10000`).

Формат вывода FAQ:

- `ВОПРОС: ...`
- `ОТВЕТ: ...`
- `[SOURCE - "Название памятки - номер слайда"]`

Название памятки по умолчанию берётся из имени каталога `out/<памятка>/...`. При необходимости можно переопределить:

```bash
python generate_faq.py --md out/<pdf>/instructions_merged.md --pamphlet-name "Моя памятка"
```

FAQ по умолчанию выгружается в **Excel (.xlsx)** с колонками:

- **Вопрос**
- **Ответ**
- **Источник**

### Генерация общей инструкции (без SOURCE‑тегов, без FAQ)

Если нужно получить один читабельный документ `general_instruction.md` **только по уже готовым инструкциям** (`instruction.txt` по страницам или `instructions_merged.md`), выполните:

```bash
python generate_general_instruction.py --input out/<pdf>/
```

или от конкретного markdown:

```bash
python generate_general_instruction.py --input out/<pdf>/instructions_merged.md
```

По умолчанию результат сохраняется рядом: `out/<pdf>/general_instruction.md`.

Чтобы дополнительно получить **DOCX** (требуется установленный `pandoc`):

```bash
python generate_general_instruction.py --input out/<pdf>/ --docx
```

Путь к pandoc можно переопределить через `PANDOC_PATH`, а reference‑шаблон — через `PANDOC_REFERENCE_DOCX` (аналогично Web UI).


### Web интерфейс

Запуск:

```bash
python web_ui.py
```

По умолчанию интерфейс поднимется на `127.0.0.1:8000` (настраивается через переменные `WEB_HOST` и `WEB_PORT` в `.env`).

В интерфейсе документа доступна выгрузка:

- итоговой инструкции (`.md`);
- итоговой инструкции (`.docx`, через `pandoc`);
- FAQ по всем страницам (`.xlsx`).

Также поддерживаются:

- загрузка **нескольких PDF** за один раз;
- массовый запуск обработки для **выбранных документов** (все страницы) и массовая генерация FAQ.

При массовых операциях Web UI показывает **progressbar** (страница задания) и обновляет прогресс автоматически.

### Простая обработка (OCR only)

В Web UI доступен упрощённый режим: **только OCR** по скриншотам страниц (`page.jpg → ocr.txt`), без merge и без incremental‑контекста.

### Авторизация: токен или mTLS (сертификаты)

По умолчанию проект работает через OAuth (получение `access_token` в NGW и заголовок `Authorization: Bearer ...`).

Если в `.env` заданы пути к сертификатам (**mTLS**), то запросы выполняются с client‑cert. Логика приоритета:

- сначала запрос пробуется **с сертификатами и без Bearer**;
- если API ответил `401/403` и токен доступен — запрос повторяется **с Bearer‑токеном**.

Переменные окружения для mTLS смотрите в `example_env.txt` (`GIGA_CLIENT_CERT`, `GIGA_CLIENT_KEY`, `GIGA_CA_BUNDLE`).

### Выгрузка инструкции в DOCX

В Web UI можно скачать итоговую инструкцию в **`.docx`**. Конвертация выполняется через **pandoc**.

Если `pandoc` не находится в `PATH`, задайте `PANDOC_PATH` в `.env`. Для “красивого” фирменного форматирования можно передать `PANDOC_REFERENCE_DOCX` (reference docx со стилями).


